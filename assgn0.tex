
\documentclass[11pt]{article}
\usepackage[a4paper, total={4in, 6in}]{geometry}
\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth 6in \textheight 8 in
% That's about enough definitions
\usepackage{color}
\usepackage{amsmath}
\usepackage{upgreek}
\usepackage{algorithm}
\usepackage{graphicx}
\usepackage{algpseudocode}

\begin{document}
\author{Abhishek Kumar\hspace{0.25cm}
Madhukant\hspace{0.25cm}
Tushar Gupta \\ 150035\hspace{1cm} 150368\hspace{1cm} 150771 \\
abhikr@iitk.ac.in mkant@iitk.ac.in tusharg@iitk.ac.in} 
\title{CS335 Assignment 0}
\maketitle

% \begin{center}
%     \begin{table}[]
%         \centering
%         \begin{tabular}{|c|c|c|}
%              \hline
%              Abhishek Kumar & 150035 & abhikr@iitk.ac.in\\
%              \hline
%              MadhuKant & 150368 & mkant@iitk.ac.in \\
%              \hline
%              Tushar Gupta & 150771 & tusharg@iitk.ac.in\\
%              \hline
%         \end{tabular}
%         \caption{Team Members}
%         \label{tab:my_label}
%     \end{table}
% \end{center}  
\begin{enumerate}
    \item \textbf{T Diagram}
    
    
    \includegraphics[scale=0.25]{T_DIAG.png}
    
    \newpage
    \item \textbf{BNF}
    % \begingroup
    % \obeylines
    % \input{bnf.tex}
    % \endgroup
   % -------------------------------------------------
    
\color{blue}
$\langle program\rangle                 ::= \langle imports\rangle\,\langle classes\rangle$\\

$\langle imports\rangle                 ::= import \,\,ID;\,\langle imports\rangle | \langle empty\rangle$\\
\color{black}
$\langle classes\rangle                 ::= \langle classes\rangle \langle class\rangle ;$\\
                          \hspace*{2.3cm}$|   \langle class\rangle ;$\\

$\langle class\rangle                   ::= class \,\,TYPE \langle inheritance\rangle \{ \langle features\_list\_opt\rangle \} ;$\\
\color{blue}

\color{black}
$\langle inheritance\rangle             ::= inherits \,\,TYPE \,\,|\,\, \langle empty\rangle$\\

$\langle features\_list\_opt\rangle       ::= \langle features\_list\rangle | \langle empty\rangle$\\

$\langle features\_list\rangle           ::= \langle features\_list\rangle \langle feature\rangle ;$\\
                          \hspace*{3.3cm}$|   \langle feature\rangle ;$\\

$\langle feature\rangle                 ::= \langle modifier\rangle \,ID ( \langle formal\_params\_list\_opt\rangle ) : TYPE \{ \langle expression\rangle \}$\\
                          \hspace*{2.4cm}$| \langle modifier\rangle\,\langle formal\rangle$\\
\color{blue}                          
$\langle modifier\rangle             ::= \,\, public\, | \,private \,|\, \langle empty\rangle$\\

\color{black}
$\langle formal\_params\_list\_opt\rangle  ::= \langle formal\_params\_list\rangle$\\
                          \hspace*{5.2cm}$|   \langle empty\rangle$\\

$\langle formal\_params\_list\rangle      ::= \langle formal\_params\_list\rangle , \langle formal\_param\rangle$\\
                          \hspace*{4.5cm}$|   \langle formal\_param\rangle$\\

$\langle formal\_param\rangle            ::= ID : TYPE $\\
\color{blue}
                                \hspace*{3.45cm}$| ID[\,\,] : TYPE$\\
\color{black}
$\langle formal\rangle                  ::= ID : TYPE <\hspace{-0.25cm}- \langle expression\rangle\,;$\\
                          \hspace*{2.3cm}$|   ID : TYPE\,;$\\
            \color{blue}
            \hspace*{2.3cm}$|   ID : TYPE\,[\langle experssion\rangle]\,;$\\
    \color{black}
$\langle expression\rangle              ::= ID <\hspace{-0.25cm}- \langle expression\rangle $\\
                    \color{blue}
                           \hspace*{3.2cm}$| ID[\langle expression\rangle] <\hspace{-0.25cm}- \langle expression\rangle$\\
                    \color{black}
                          \hspace*{3.2cm}$|   \langle expression\rangle.ID( \langle arguments\_list\_opt\rangle )$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle @TYPE.ID( \langle arguments\_list\_opt\rangle )$\\
                          \hspace*{3.2cm}$|   \langle if\_then\_else\rangle$\\
                          \hspace*{3.2cm}$|   \langle while\rangle $\\
                          \color{blue}
                          \hspace*{3.2cm}$|   \langle for\rangle$\\
                          \color{black}
                          \hspace*{3.2cm}$|   \langle block\_expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle let\_expression\rangle$\\
                          \hspace*{3.2cm}$|   new TYPE$\\
                          \hspace*{3.2cm}$|   isvoid \langle expr\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle + \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle - \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle * \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle / \langle expression\rangle$\\
                          \color{blue}
                          \hspace*{3.2cm}$|   \langle expression\rangle \% \langle expression\rangle$\\
                          \color{black}
                          \hspace*{3.2cm}$|   ~ \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle \, <  \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle \,<= \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle = \langle expression\rangle$\\
                          \color{blue}
                          \hspace*{3.2cm}$|   \langle expression\rangle \,> \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle \, >= \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle \, or \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle \, and \langle expression\rangle$\\
                          \color{black}
                          \hspace*{3.2cm}$|   not \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   ( \langle expression\rangle )$\\
                          \hspace*{3.2cm}$|   SELF$\\
                          \hspace*{3.2cm}$|   ID$\\
                          \color{blue}
                          \hspace*{3.2cm}$|   ID[\langle expression\rangle]$\\
                          \color{black}
                          \hspace*{3.2cm}$|   INTEGER$\\
                          \hspace*{3.2cm}$|   STRING$\\
                          \hspace*{3.2cm}$|   TRUE$\\
                          \hspace*{3.2cm}$|   FALSE$\\
                          \color{blue}
                          \hspace*{3.2cm}$|   BREAK$\\
                          \hspace*{3.2cm}$|   CONTINUE$\\
                          \color{black}

$\langle arguments\_list\_opt\rangle      ::= \langle arguments\_list\rangle$\\
                          \hspace*{4.5cm}$|   \langle empty\rangle$\\

$\langle arguments\_list\rangle          ::= \langle arguments\_list\_opt\rangle , \langle expression\rangle$\\
                          \hspace*{4.1cm}$|   \langle expression\rangle$\\

% $\langle case\rangle                    ::= case \langle expression\rangle of \langle actions\rangle esac$\\

$\langle action\rangle                  ::= ID : TYPE => \langle expr\rangle$\\

$\langle actions\rangle                 ::= \langle action\rangle$\\
                          \hspace*{2.7cm}$|   \langle action\rangle \langle actions\rangle$\\

$\langle if\_then\_else\rangle            ::= if \langle expression\rangle then \langle expression\rangle else \langle expression\rangle fi$\\

$\langle while\rangle                   ::= while \langle expression\rangle loop \langle expression\rangle pool$\\
\color{blue}
$\langle for\rangle                   ::= for ( \langle expression\rangle ; \langle expression\rangle ; \langle expression\rangle ) loop \langle expression\rangle pool$\\
\color{black}

$\langle block\_expression \rangle        ::= { \langle block\_list\rangle }$\\

$\langle block\_list\rangle              ::= \langle block\_list\rangle \langle expression\rangle ;$\\
                          \hspace*{3.2cm}$|   \langle expression\rangle ;$\\
    
$\langle let\_expression\rangle          ::= let \langle formal\rangle in \langle expression\rangle$\\
                          \hspace*{3.8cm}$|   \langle nested\_lets\rangle , \langle formal\rangle$\\

$\langle nested\_lets\rangle            ::= \langle formal\rangle IN \langle expression\rangle$\\
                          \hspace*{3.2cm}$|   \langle nested\_lets\rangle , \langle formal\rangle$\\

$\langle empty\rangle                   ::=  $\\

    
    
    %------------------------------------------------
    \item \textbf{Syntactic rules deleted from base Language}\\
    $\langle case\rangle                    ::= case \langle expression\rangle of \langle actions\rangle esac$\\
    \item \textbf{Reserved Keyword} 
    \begin{itemize}
        \item Int
        \item String
        \item Object
        \item and
        \item case
        \item class
        \item else
        \item esac
        \item fi
        \item if 
        \item import
        \item in
        \item inherits
        \item isvoid
        \item for
        \item let
        \item loop
        \item new
        \item not
        \item or
        \item of
        \item pool
        \item public
        \item private
        \item self
        \item then
        \item while

    \end{itemize}
    \item \textbf{Semantic description of the new constructs added}
    \begin{itemize}
        \item \textbf{import}\\
        \textit{import} statement is used to bring certain classes or the entire packages, into visibility. For example if we have to create a list of integers, we can import a list package(already written COOL file) and create a list object and use functions on it

    \begin{verbatim}
    import List;
    
    ....
    
    L = new List;
    L.append(1);
\end{verbatim}
This code compiles correctly if we have package named List.cl and has append function defined in it. \textit{import} declaration section is a compile-time element of the source codes, and has no presence at run-time
        
    
        \item \textbf{for-loop}\\
        A \textit{for} loop, as described in the BNF above, has the following structure: 
        \begin{verbatim}
            for(expr_1; expr_2; expr_3)
            loop
                expr_block;
            pool
        \end{verbatim}
        The execution protocol is as follows:\\
        \begin{itemize}
            \item {expr\_1 is initialization, executed only once before the execution of the for loop}
            \item {expr\_2 is condition, evaluated before each iteration of the loop. If expr\_2 evaluates to \textbf{TRUE}, then the expr\_block is executed. However, if expr\_2 is evaluated to be \textbf{FALSE}, for loop is broken out of and control reaches the statement after the \textit{pool} keyword}
            \item{expr\_3 is updation, executed after the execution of each iteration of the loop}
        \end{itemize}
        
        For example, the code below:
        \begin{verbatim}
            for(i<-0; i<5; i<-i+1)
            loop{
                out_int(i)
            }pool
        \end{verbatim}
        outputs:
        \begin{verbatim}
            01234
        \end{verbatim}
        
        
        \item \textbf{Access Modifiers} We allow two access modifiers - \textit{public, private}. By default all the classes, methods and  variables in class are public. Class variables can be made private barring direct access to these variables from outside the class(will need getter and setter functions). A method can be declared as private can be called from inside the class only.
        
        \item \textbf{Array} An array is a group of like-typed variables that are referred to by a common name. This language only provide static allocation of array. Array can be declared by - 
        \begin{verbatim}
            arr : Int[10];
        \end{verbatim}
        \vspace{-0.5cm}
        Its assignment is done by 
        \begin{verbatim}
            arr[0] <- 5;
            arr[1] <- 6;
            .
            .
        \end{verbatim}
        \vspace{-0.5cm}
        
        \item \textbf{BREAK \& CONTINUE}\\
        
        \textbf{BREAK} is used to exit from the current running loop.\\ When the break statement is encountered inside a loop, the loop is immediately terminated and the program control resumes at the next statement following the loop.\\
        
        \textbf{CONTINUE} is used to skip the current iteration in loop. \\
        In for loop, after the continue keyword control reaches to the updation step of iterating variable
        In while loop after the continue keyword control flow reaches to the boolean check expression
        
        \item \textbf{Operator}
        Some operator are added to the original COOL language. Operators added are -
        \begin{itemize}
            \item \textbf{\%} - It is the modulus operator which gives the remainder of the two operands-
            \begin{verbatim}
            c <- a % b
            \end{verbatim}
            \vspace{-0.5cm}
            variable c gets remainder of division when variable a is divided by variable b.
            
            \item \textbf{$>=,>$} these are the general "greater than or equal to" and "greater than" operators
            \item \textbf{or} is used as the general 'logical or' operator on two boolean expressions.
            \item \textbf{and} is used as the general 'logical and' operator on two boolean expressions.
        \end{itemize}
        
    \end{itemize}
    
    
    
    
    
    
    \item \textbf{Tool} to be used for lexing and parsing are from PLY library of python.
    
    
\end{enumerate}
\end{document}