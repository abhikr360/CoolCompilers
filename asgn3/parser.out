Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    THEN
    DIVIDE
    GTEQ
    TIMES
    OBJECT
    STRING_TYPE
    WHILE
    IMPORT
    NEW
    PLUS
    FI
    TRUE
    MINUS
    BOOL_TYPE
    PRIVATE
    ISVOID
    INTEGER_TYPE
    LT
    TILDA
    INTEGER
    IN
    GETS
    GT
    FOR
    PERIOD
    EQUAL
    AT
    RSQRBRACKET
    ELSE
    LSQRBRACKET
    POOL
    IF
    AND
    FALSE
    LTEQ
    OR
    BREAK
    SELF
    CONTINUE
    LET
    NOT
    COMMA
    PUBLIC
    LOOP
    MOD

Grammar

Rule 0     S' -> program
Rule 1     program -> classes
Rule 2     classes -> class SEMICOLON
Rule 3     classes -> classes class SEMICOLON
Rule 4     class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE
Rule 5     features_list -> feature SEMICOLON
Rule 6     feature -> ID LPAREN RPAREN COLON type LBRACE expression RBRACE
Rule 7     type -> SELF_TYPE
Rule 8     expression -> ID LPAREN argument_list RPAREN
Rule 9     argument_list -> expression
Rule 10    expression -> STRING

Terminals, with rules where they appear

AND                  : 
AT                   : 
BOOL_TYPE            : 
BREAK                : 
CLASS                : 4
CLASS_TYPE           : 4 4
COLON                : 6
COMMA                : 
CONTINUE             : 
DIVIDE               : 
ELSE                 : 
EQUAL                : 
FALSE                : 
FI                   : 
FOR                  : 
GETS                 : 
GT                   : 
GTEQ                 : 
ID                   : 6 8
IF                   : 
IMPORT               : 
IN                   : 
INHERITS             : 4
INTEGER              : 
INTEGER_TYPE         : 
ISVOID               : 
LBRACE               : 4 6
LET                  : 
LOOP                 : 
LPAREN               : 6 8
LSQRBRACKET          : 
LT                   : 
LTEQ                 : 
MINUS                : 
MOD                  : 
NEW                  : 
NOT                  : 
OBJECT               : 
OR                   : 
PERIOD               : 
PLUS                 : 
POOL                 : 
PRIVATE              : 
PUBLIC               : 
RBRACE               : 4 6
RPAREN               : 6 8
RSQRBRACKET          : 
SELF                 : 
SELF_TYPE            : 7
SEMICOLON            : 2 3 5
STRING               : 10
STRING_TYPE          : 
THEN                 : 
TILDA                : 
TIMES                : 
TRUE                 : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argument_list        : 8
class                : 2 3
classes              : 1 3
expression           : 6 9
feature              : 5
features_list        : 4
program              : 0
type                 : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes
    (2) classes -> . class SEMICOLON
    (3) classes -> . classes class SEMICOLON
    (4) class -> . CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE

    CLASS           shift and go to state 2

    classes                        shift and go to state 3
    program                        shift and go to state 1
    class                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (4) class -> CLASS . CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE

    CLASS_TYPE      shift and go to state 5


state 3

    (1) program -> classes .
    (3) classes -> classes . class SEMICOLON
    (4) class -> . CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE

    $end            reduce using rule 1 (program -> classes .)
    CLASS           shift and go to state 2

    class                          shift and go to state 6

state 4

    (2) classes -> class . SEMICOLON

    SEMICOLON       shift and go to state 7


state 5

    (4) class -> CLASS CLASS_TYPE . INHERITS CLASS_TYPE LBRACE features_list RBRACE

    INHERITS        shift and go to state 8


state 6

    (3) classes -> classes class . SEMICOLON

    SEMICOLON       shift and go to state 9


state 7

    (2) classes -> class SEMICOLON .

    CLASS           reduce using rule 2 (classes -> class SEMICOLON .)
    $end            reduce using rule 2 (classes -> class SEMICOLON .)


state 8

    (4) class -> CLASS CLASS_TYPE INHERITS . CLASS_TYPE LBRACE features_list RBRACE

    CLASS_TYPE      shift and go to state 10


state 9

    (3) classes -> classes class SEMICOLON .

    CLASS           reduce using rule 3 (classes -> classes class SEMICOLON .)
    $end            reduce using rule 3 (classes -> classes class SEMICOLON .)


state 10

    (4) class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE . LBRACE features_list RBRACE

    LBRACE          shift and go to state 11


state 11

    (4) class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE . features_list RBRACE
    (5) features_list -> . feature SEMICOLON
    (6) feature -> . ID LPAREN RPAREN COLON type LBRACE expression RBRACE

    ID              shift and go to state 14

    features_list                  shift and go to state 12
    feature                        shift and go to state 13

state 12

    (4) class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list . RBRACE

    RBRACE          shift and go to state 15


state 13

    (5) features_list -> feature . SEMICOLON

    SEMICOLON       shift and go to state 16


state 14

    (6) feature -> ID . LPAREN RPAREN COLON type LBRACE expression RBRACE

    LPAREN          shift and go to state 17


state 15

    (4) class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE .

    SEMICOLON       reduce using rule 4 (class -> CLASS CLASS_TYPE INHERITS CLASS_TYPE LBRACE features_list RBRACE .)


state 16

    (5) features_list -> feature SEMICOLON .

    RBRACE          reduce using rule 5 (features_list -> feature SEMICOLON .)


state 17

    (6) feature -> ID LPAREN . RPAREN COLON type LBRACE expression RBRACE

    RPAREN          shift and go to state 18


state 18

    (6) feature -> ID LPAREN RPAREN . COLON type LBRACE expression RBRACE

    COLON           shift and go to state 19


state 19

    (6) feature -> ID LPAREN RPAREN COLON . type LBRACE expression RBRACE
    (7) type -> . SELF_TYPE

    SELF_TYPE       shift and go to state 20

    type                           shift and go to state 21

state 20

    (7) type -> SELF_TYPE .

    LBRACE          reduce using rule 7 (type -> SELF_TYPE .)


state 21

    (6) feature -> ID LPAREN RPAREN COLON type . LBRACE expression RBRACE

    LBRACE          shift and go to state 22


state 22

    (6) feature -> ID LPAREN RPAREN COLON type LBRACE . expression RBRACE
    (8) expression -> . ID LPAREN argument_list RPAREN
    (10) expression -> . STRING

    ID              shift and go to state 24
    STRING          shift and go to state 25

    expression                     shift and go to state 23

state 23

    (6) feature -> ID LPAREN RPAREN COLON type LBRACE expression . RBRACE

    RBRACE          shift and go to state 26


state 24

    (8) expression -> ID . LPAREN argument_list RPAREN

    LPAREN          shift and go to state 27


state 25

    (10) expression -> STRING .

    RPAREN          reduce using rule 10 (expression -> STRING .)
    RBRACE          reduce using rule 10 (expression -> STRING .)


state 26

    (6) feature -> ID LPAREN RPAREN COLON type LBRACE expression RBRACE .

    SEMICOLON       reduce using rule 6 (feature -> ID LPAREN RPAREN COLON type LBRACE expression RBRACE .)


state 27

    (8) expression -> ID LPAREN . argument_list RPAREN
    (9) argument_list -> . expression
    (8) expression -> . ID LPAREN argument_list RPAREN
    (10) expression -> . STRING

    ID              shift and go to state 24
    STRING          shift and go to state 25

    expression                     shift and go to state 29
    argument_list                  shift and go to state 28

state 28

    (8) expression -> ID LPAREN argument_list . RPAREN

    RPAREN          shift and go to state 30


state 29

    (9) argument_list -> expression .

    RPAREN          reduce using rule 9 (argument_list -> expression .)


state 30

    (8) expression -> ID LPAREN argument_list RPAREN .

    RPAREN          reduce using rule 8 (expression -> ID LPAREN argument_list RPAREN .)
    RBRACE          reduce using rule 8 (expression -> ID LPAREN argument_list RPAREN .)

